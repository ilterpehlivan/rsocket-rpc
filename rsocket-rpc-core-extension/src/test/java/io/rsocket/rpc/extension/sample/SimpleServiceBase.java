package io.rsocket.rpc.extension.sample;

// Below is supposed to be created as STUB

import static io.grpc.MethodDescriptor.generateFullMethodName;

import com.google.protobuf.Empty;
import com.google.protobuf.Message;
import io.grpc.BindableService;
import io.grpc.MethodDescriptor;
import io.grpc.MethodDescriptor.MethodType;
import io.grpc.ServerServiceDefinition;
import io.grpc.protobuf.ProtoUtils;
import io.netty.buffer.ByteBuf;
import io.rsocket.rpc.core.extension.routing.ServerCalls;
import io.rsocket.rpc.core.extension.routing.ServerCalls.BiDirectionStreamingMethod;
import io.rsocket.rpc.core.extension.routing.ServerCalls.ClientStreamingMethod;
import io.rsocket.rpc.core.extension.routing.ServerCalls.FireAndForgetMethod;
import io.rsocket.rpc.core.extension.routing.ServerCalls.RequestResponseMethod;
import io.rsocket.rpc.extension.sample.proto.SimpleRequest;
import io.rsocket.rpc.extension.sample.proto.SimpleResponse;
import lombok.extern.slf4j.Slf4j;
import org.reactivestreams.Publisher;
import reactor.core.publisher.Flux;

@Slf4j
public abstract class SimpleServiceBase implements BindableService {

  private static final int METHOD_REQUEST_RESPONSE_ID = 1;
  private static final int METHOD_FIRE_FORGET_ID = 2;
  private static final int METHOD_REQUEST_STREAM_ID = 3;
  private static final int METHOD_BIDI_STREAM_ID = 4;

  public static String SERVICE = "io.rsocket.rpc.extension.sample.SimpleService";
  public static String METHOD_REQUEST_REPLY = "requestReply";
  public static String METHOD_FIRE_AND_FORGET = "fireAndForget";
  public static String METHOD_REQUEST_STREAM = "requestStream";
  public static String METHOD_STREAMING_REQUEST_SINGLE_RESPONSE = "StreamingRequestSingleResponse";
  public static String METHOD_STREAMING_REQUEST_AND_RESPONSE = "streamingRequestAndResponse";

  // Those methods are auto-generated by plugin
  public abstract reactor.core.publisher.Mono<SimpleResponse> requestReply(
      SimpleRequest message, io.netty.buffer.ByteBuf metadata);

  public abstract reactor.core.publisher.Mono<Empty> fireAndForget(
      SimpleRequest message, io.netty.buffer.ByteBuf metadata);

  public abstract reactor.core.publisher.Flux<SimpleResponse> requestStream(
      SimpleRequest message, io.netty.buffer.ByteBuf metadata);

  public abstract reactor.core.publisher.Flux<SimpleResponse> streamingRequestAndResponse(
      Publisher<SimpleRequest> messages, io.netty.buffer.ByteBuf metadata);

  @Override
  public ServerServiceDefinition bindService() {
    return ServerServiceDefinition.builder(SERVICE)
        .addMethod(
        this.<SimpleRequest,SimpleResponse>getRequestResponseMethod(SERVICE, METHOD_REQUEST_REPLY, MethodType.UNARY,
            SimpleRequest.getDefaultInstance(),SimpleResponse.getDefaultInstance()),
            ServerCalls.requestReply(
                new MethodHandlers<SimpleRequest, SimpleResponse>(
                    this, METHOD_REQUEST_RESPONSE_ID)))
        .addMethod(
            getFireForgetMethod(SERVICE, METHOD_FIRE_AND_FORGET, MethodType.UNARY),
            ServerCalls.requestReply(
                new MethodHandlers<SimpleRequest, Empty>(this, METHOD_FIRE_FORGET_ID)))
        .addMethod(
            getRequestResponseMethod(SERVICE, METHOD_REQUEST_STREAM, MethodType.CLIENT_STREAMING,
                SimpleRequest.getDefaultInstance(),SimpleResponse.getDefaultInstance()),
            ServerCalls.requestReply(
                new MethodHandlers<SimpleRequest, SimpleResponse>(this, METHOD_REQUEST_STREAM_ID)))
        .addMethod(
            getRequestResponseMethod(
                SERVICE, METHOD_STREAMING_REQUEST_AND_RESPONSE, MethodType.BIDI_STREAMING,
                SimpleRequest.getDefaultInstance(),SimpleResponse.getDefaultInstance()),
            ServerCalls.requestReply(
                new MethodHandlers<>(this, METHOD_BIDI_STREAM_ID)))
        .build();
  }

  private <TRequest extends Message,TResponse extends Message> MethodDescriptor<TRequest, TResponse> getRequestResponseMethod(
      String service, String method, MethodType methodType, final TRequest requestInstance,final TResponse responseInstance) {
    return MethodDescriptor.<TRequest, TResponse>newBuilder()
        .setFullMethodName(generateFullMethodName(service, method))
        .setType(methodType)
        .setRequestMarshaller(ProtoUtils.<TRequest>marshaller(requestInstance))
        .setResponseMarshaller(ProtoUtils.<TResponse>marshaller(responseInstance))
        .setSampledToLocalTracing(true)
        .build();
  }

  private MethodDescriptor<SimpleRequest, Empty> getFireForgetMethod(
      String service, String method, MethodType methodType) {
    return MethodDescriptor.<SimpleRequest, Empty>newBuilder()
        .setFullMethodName(generateFullMethodName(service, method))
        .setType(methodType)
        .setRequestMarshaller(ProtoUtils.marshaller(SimpleRequest.getDefaultInstance()))
        .setResponseMarshaller(ProtoUtils.marshaller(Empty.getDefaultInstance()))
        .setSampledToLocalTracing(true)
        .build();
  }

  private class MethodHandlers<Req, Resp>
      implements RequestResponseMethod<Req, Resp>,
          FireAndForgetMethod<Req, Resp>,
          ClientStreamingMethod<Req, Resp>,
          BiDirectionStreamingMethod<Req, Resp> {

    private final SimpleServiceBase serviceImpl;
    private final int methodId;

    public MethodHandlers(SimpleServiceBase service, int methodRequestResponse) {
      this.methodId = methodRequestResponse;
      this.serviceImpl = service;
    }

    @Override
    @java.lang.SuppressWarnings("unchecked")
    public Flux<Resp> apply(Req req, ByteBuf byteBuf) {
      log.info("inside the apply for the methodid {}", methodId);
      switch (methodId) {
        case METHOD_REQUEST_RESPONSE_ID:
          return (Flux<Resp>) serviceImpl.requestReply((SimpleRequest) req, byteBuf).flux();
        case METHOD_FIRE_FORGET_ID:
          return (Flux<Resp>) serviceImpl.fireAndForget((SimpleRequest) req, byteBuf).flux();
        case METHOD_REQUEST_STREAM_ID:
          return (Flux<Resp>) serviceImpl.requestStream((SimpleRequest) req, byteBuf);
        default:
          return reactor.core.publisher.Flux.error(new UnsupportedOperationException());
      }
    }

    //    // TODO: merge this with apply
    //    @Override
    //    @java.lang.SuppressWarnings("unchecked")
    //    public Flux<Resp> applyMany(Req req, ByteBuf byteBuf) {
    //      log.info("inside the applyMany for the methodid {}", methodId);
    //      switch (methodId) {
    //        case METHOD_REQUEST_STREAM_ID:
    //          return (Flux<Resp>) serviceImpl.requestStream((SimpleRequest) req, byteBuf);
    //        default:
    //          {
    //            return reactor.core.publisher.Flux.error(new UnsupportedOperationException());
    //          }
    //      }
    //    }

    @Override
    @java.lang.SuppressWarnings("unchecked")
    public Flux<Resp> apply(Publisher<Req> publisher, ByteBuf byteBuf) {
      log.info("inside the apply bidirect for the methodid {}", methodId);
      switch (methodId) {
        case METHOD_BIDI_STREAM_ID:
          return (Flux<Resp>)
              serviceImpl.streamingRequestAndResponse(
                  Flux.from((Publisher<SimpleRequest>) publisher), byteBuf);
        default:
          {
            return reactor.core.publisher.Flux.error(new UnsupportedOperationException());
          }
      }
    }
  }
}
